// Copyright 2001-2005 freehep
package org.freehep.graphicsio.pdf;

import java.awt.font.FontRenderContext;
import java.io.IOException;
import java.util.ArrayList;

import org.freehep.graphics2d.font.CharTable;
import org.freehep.graphics2d.font.CustomCharTable;
import org.freehep.graphicsio.font.FontEmbedder;

/**
 * Superclass of all FontEmbedders for PDF documents. Subclasses must implement
 * all abstract methods which are called in the following order:
 * <ul>
 * <li>addAdditionalEntries
 * <li>addAdditionalInitDicts
 * <li>writeGlyph once for each glyph in the order of the encoding
 * </ul>
 * 
 * @author Simon Fischer
 * @author Alexander Levantovsky, MagicPlot
 * @version $Id: freehep-graphicsio-pdf/src/main/java/org/freehep/graphicsio/pdf/PDFFontEmbedder.java f493ff6e61b2 2005/12/01 18:46:43 duns $
 */
public abstract class PDFFontEmbedder extends FontEmbedder {

    /** sloppily declared protected */
    protected PDFWriter pdf;

    private PDFDictionary fontDict;

    private String reference;

    private PDFRedundanceTracker redundanceTracker;

    public PDFFontEmbedder(FontRenderContext context, PDFWriter pdf,
            String reference, PDFRedundanceTracker tracker) {
        super(context);
        this.pdf = pdf;
        this.reference = reference;
        this.redundanceTracker = tracker;
    }

    /** Returns the font subtype (currently only Type3). */
    protected abstract String getSubtype();

    /** Add additional entries to the font Dictionary. */
    protected abstract void addAdditionalEntries(PDFDictionary fontDict)
            throws IOException;

    /**
     * Add additional dicionaries to the PDFWriter which may be referenced by
     * entries generated by <tt>addAdditionalEntries()</tt>
     */
    protected abstract void addAdditionalInitDicts() throws IOException;

    /**
     * Returns the reference String that identifies the font dictionary. Use
     * this reference plus underscore plus suffix for other dictionaries.
     */
    protected String getReference() {
        return reference;
    }

    protected void openIncludeFont() throws IOException {

        fontDict = pdf.openDictionary(reference);

        fontDict.entry("Type", pdf.name("Font"));
        fontDict.entry("Subtype", pdf.name(getSubtype()));
        fontDict.entry("Name", pdf.name(getFontName()));

        fontDict.entry("FirstChar", 0);
        fontDict.entry("LastChar", 255);
        fontDict.entry("Encoding", redundanceTracker.getReference(
                getEncodingTable(), PDFCharTableWriter.getInstance()));
        fontDict.entry("Widths", pdf.ref(reference + "Widths"));
        if (getEncodingTable() instanceof CustomCharTable)
            fontDict.entry("ToUnicode", pdf.ref(reference + "ToUnicode"));

        addAdditionalEntries(fontDict);

        pdf.close(fontDict);

        addAdditionalInitDicts();

        if (getEncodingTable() instanceof CustomCharTable)
            writeToUnicode(pdf, reference + "ToUnicode", getEncodingTable());
    }

    protected void closeEmbedFont() {
    }
    
    public static void writeToUnicode(PDFWriter pdf, String ref, CharTable charTable) throws IOException {
        PDFStream toUnicode = pdf.openStream(ref);
        
        toUnicode.println("/CIDInit /ProcSet findresource begin");
        toUnicode.println("12 dict begin");
        toUnicode.println("begincmap");
        
        toUnicode.println("/CMapType 2 def");
        toUnicode.println("/CMapName /" + ref + " def");
        
        toUnicode.println("1 begincodespacerange");
        toUnicode.println("<00><FF>");
        toUnicode.println("endcodespacerange");
        
        ArrayList<String> bfchars = new ArrayList<String>();
        for (int i = 0; i < 100; i++) {
            String name = charTable.toName(i);
            if (name != null) {
                char unicode = charTable.toUnicode(name);
                bfchars.add("<" + CustomCharTable.unicodeToHex(i, 2) + "><" + CustomCharTable.unicodeToHex(unicode, 4) + ">");
            }
        }
        
        int charsWritten = 0;
        while (charsWritten < bfchars.size()) {
            int writeNow = Math.min(bfchars.size() - charsWritten, 100);
            
            toUnicode.println(writeNow + " beginbfchar");
            for (int i = 0; i < writeNow; i++) {
                toUnicode.println(bfchars.get(charsWritten++));
            }
            toUnicode.println("endbfchar");
        }

        toUnicode.println("endcmap");
        toUnicode.println("CMapName currentdict /CMap defineresource pop");
        toUnicode.println("end");
        toUnicode.println("end");
        
        pdf.close(toUnicode);
    }
            
    protected void writeWidths(double[] widths) throws IOException {
        Object[] widthsObj = new Object[256];
        for (int i = 0; i < widthsObj.length; i++) {
            widthsObj[i] = new Double(widths[i]);
        }
        pdf.object(reference + "Widths", widthsObj);
    }

    protected void writeEncoding(CharTable charTable) throws IOException {
        // NOT USED!!! See PDFCharTableWriter.writeObject() method - Levantovsky
    }

    protected String createCharacterReference(String characterName) {
        return "Glyph_" + reference + ":" + characterName;
    }
}
